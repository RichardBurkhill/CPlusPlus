#ifndef DDS_COMMUNICATOR_HPP
#define DDS_COMMUNICATOR_HPP

#include <iostream>
#include <string>
#include <stdexcept> // For std::runtime_error

// Include RTI Connext DDS headers
// Ensure your build system can find these headers (e.g., by setting include paths)
#include <dds/dds.hpp> // Modern C++ API (if using) or traditional C API headers
#include <ndds/ndds_cpp.h> // Traditional C++ API (more common for rtiddsgen)

// Forward declare listener base class if not fully included yet
// This is typically part of the generated code or ndds_cpp.h
// class DDS_DataReaderListener; // Already in ndds_cpp.h

/**
 * @brief A templated DDS communication class for RTI Connext DDS.
 *
 * This class provides a simplified interface for publishing and subscribing
 * to DDS topics using types generated by rtiddsgen.
 *
 * @tparam T The rtiddsgen-generated data type (e.g., MyType).
 * @tparam TSeq The rtiddsgen-generated sequence type for T (e.g., MyTypeSeq).
 * @tparam TTypeSupport The rtiddsgen-generated TypeSupport class for T (e.g., MyTypeTypeSupport).
 */
template <typename T, typename TSeq, typename TTypeSupport>
class DDSCommunicator {
public:
    /**
     * @brief Constructor for DDSCommunicator.
     * @param domainId The DDS domain ID.
     * @param topicName The name of the DDS topic.
     */
    DDSCommunicator(int domainId, const std::string& topicName)
        : _domainId(domainId),
          _topicName(topicName),
          _participant(nullptr),
          _publisher(nullptr),
          _subscriber(nullptr),
          _topic(nullptr),
          _writer(nullptr),
          _reader(nullptr),
          _isInitialized(false) {}

    /**
     * @brief Destructor. Cleans up all DDS entities.
     */
    ~DDSCommunicator() {
        cleanup();
    }

    /**
     * @brief Initializes the communicator as a publisher.
     * @return True if initialization is successful, false otherwise.
     */
    bool initPublisher() {
        if (_isInitialized) {
            std::cerr << "DDSCommunicator already initialized." << std::endl;
            return false;
        }

        try {
            // 1. Create DomainParticipant
            _participant = DDS_DomainParticipantFactory_create_participant(
                DDS_TheParticipantFactory,
                _domainId,
                DDS_PARTICIPANT_QOS_DEFAULT, // Use default QoS
                nullptr, // No listener for participant
                DDS_STATUS_MASK_NONE);
            if (!_participant) {
                throw std::runtime_error("Failed to create DomainParticipant.");
            }
            std::cout << "DomainParticipant created for domain " << _domainId << std::endl;

            // 2. Register the type
            DDS_ReturnCode_t retcode = TTypeSupport::register_type(_participant, TTypeSupport::get_type_name());
            if (retcode != DDS_RETCODE_OK) {
                throw std::runtime_error("Failed to register type: " + std::string(TTypeSupport::get_type_name()));
            }
            std::cout << "Type '" << TTypeSupport::get_type_name() << "' registered." << std::endl;

            // 3. Create Topic
            _topic = DDS_DomainParticipant_create_topic(
                _participant,
                _topicName.c_str(),
                TTypeSupport::get_type_name(),
                DDS_TOPIC_QOS_DEFAULT, // Use default QoS
                nullptr, // No listener for topic
                DDS_STATUS_MASK_NONE);
            if (!_topic) {
                throw std::runtime_error("Failed to create Topic: " + _topicName);
            }
            std::cout << "Topic '" << _topicName << "' created." << std::endl;

            // 4. Create Publisher
            _publisher = DDS_DomainParticipant_create_publisher(
                _participant,
                DDS_PUBLISHER_QOS_DEFAULT, // Use default QoS
                nullptr, // No listener for publisher
                DDS_STATUS_MASK_NONE);
            if (!_publisher) {
                throw std::runtime_error("Failed to create Publisher.");
            }
            std::cout << "Publisher created." << std::endl;

            // 5. Create DataWriter
            _writer = DDS_Publisher_create_datawriter(
                _publisher,
                _topic,
                DDS_DATAWRITER_QOS_DEFAULT, // Use default QoS
                nullptr, // No listener for datawriter
                DDS_STATUS_MASK_NONE);
            if (!_writer) {
                throw std::runtime_error("Failed to create DataWriter.");
            }
            std::cout << "DataWriter created." << std::endl;

            _isInitialized = true;
            return true;

        } catch (const std::runtime_error& e) {
            std::cerr << "Publisher initialization failed: " << e.what() << std::endl;
            cleanup(); // Clean up any partially created entities
            return false;
        }
    }

    /**
     * @brief Initializes the communicator as a subscriber.
     * @param listener A pointer to a DDS_DataReaderListener implementation.
     *                 The listener must be allocated by the caller and remain valid
     *                 for the lifetime of the DDSCommunicator.
     * @return True if initialization is successful, false otherwise.
     */
    bool initSubscriber(DDS_DataReaderListener* listener) {
        if (_isInitialized) {
            std::cerr << "DDSCommunicator already initialized." << std::endl;
            return false;
        }
        if (!listener) {
            std::cerr << "Subscriber listener cannot be null." << std::endl;
            return false;
        }

        try {
            // 1. Create DomainParticipant
            _participant = DDS_DomainParticipantFactory_create_participant(
                DDS_TheParticipantFactory,
                _domainId,
                DDS_PARTICIPANT_QOS_DEFAULT,
                nullptr,
                DDS_STATUS_MASK_NONE);
            if (!_participant) {
                throw std::runtime_error("Failed to create DomainParticipant.");
            }
            std::cout << "DomainParticipant created for domain " << _domainId << std::endl;

            // 2. Register the type
            DDS_ReturnCode_t retcode = TTypeSupport::register_type(_participant, TTypeSupport::get_type_name());
            if (retcode != DDS_RETCODE_OK) {
                throw std::runtime_error("Failed to register type: " + std::string(TTypeSupport::get_type_name()));
            }
            std::cout << "Type '" << TTypeSupport::get_type_name() << "' registered." << std::endl;

            // 3. Create Topic
            _topic = DDS_DomainParticipant_create_topic(
                _participant,
                _topicName.c_str(),
                TTypeSupport::get_type_name(),
                DDS_TOPIC_QOS_DEFAULT,
                nullptr,
                DDS_STATUS_MASK_NONE);
            if (!_topic) {
                throw std::runtime_error("Failed to create Topic: " + _topicName);
            }
            std::cout << "Topic '" << _topicName << "' created." << std::endl;

            // 4. Create Subscriber
            _subscriber = DDS_DomainParticipant_create_subscriber(
                _participant,
                DDS_SUBSCRIBER_QOS_DEFAULT,
                nullptr,
                DDS_STATUS_MASK_NONE);
            if (!_subscriber) {
                throw std::runtime_error("Failed to create Subscriber.");
            }
            std::cout << "Subscriber created." << std::endl;

            // 5. Create DataReader with the provided listener
            _reader = DDS_Subscriber_create_datareader(
                _subscriber,
                _topic,
                DDS_DATAREADER_QOS_DEFAULT, // Use default QoS
                listener, // Attach the user-provided listener
                DDS_STATUS_MASK_ALL); // Listen for all status changes (e.g., data available)
            if (!_reader) {
                throw std::runtime_error("Failed to create DataReader.");
            }
            std::cout << "DataReader created with listener." << std::endl;

            _isInitialized = true;
            return true;

        } catch (const std::runtime_error& e) {
            std::cerr << "Subscriber initialization failed: " << e.what() << std::endl;
            cleanup();
            return false;
        }
    }

    /**
     * @brief Publishes data to the DDS topic.
     * @param data The data instance to publish.
     * @return True if data is successfully written, false otherwise.
     */
    bool publish(const T& data) {
        if (!_isInitialized || !_writer) {
            std::cerr << "DDSCommunicator not initialized as a publisher or DataWriter is null." << std::endl;
            return false;
        }

        DDS_ReturnCode_t retcode = TTypeSupport::narrow(_writer)->write(data, &DDS_HANDLE_NIL);
        if (retcode != DDS_RETCODE_OK) {
            std::cerr << "Failed to write data, error: " << retcode << std::endl;
            return false;
        }
        return true;
    }

    /**
     * @brief Checks if the DDSCommunicator has been successfully initialized.
     * @return True if initialized, false otherwise.
     */
    bool isInitialized() const {
        return _isInitialized;
    }

private:
    int _domainId;
    std::string _topicName;
    bool _isInitialized;

    DDSDomainParticipant* _participant;
    DDSPublisher* _publisher;
    DDSSubscriber* _subscriber;
    DDSTopic* _topic;
    DDSDataWriter* _writer;
    DDSDataReader* _reader;

    /**
     * @brief Cleans up all DDS entities in reverse order of creation.
     */
    void cleanup() {
        if (_participant) {
            std::cout << "Cleaning up DDS entities..." << std::endl;

            if (_writer) {
                DDS_Publisher_delete_datawriter(_publisher, _writer);
                _writer = nullptr;
            }
            if (_reader) {
                // Note: The listener is NOT deleted here. It's owned by the caller.
                DDS_Subscriber_delete_datareader(_subscriber, _reader);
                _reader = nullptr;
            }
            if (_publisher) {
                DDS_DomainParticipant_delete_publisher(_participant, _publisher);
                _publisher = nullptr;
            }
            if (_subscriber) {
                DDS_DomainParticipant_delete_subscriber(_participant, _subscriber);
                _subscriber = nullptr;
            }
            if (_topic) {
                DDS_DomainParticipant_delete_topic(_participant, _topic);
                _topic = nullptr;
            }

            DDS_DomainParticipantFactory_delete_participant(DDS_TheParticipantFactory, _participant);
            _participant = nullptr;
            std::cout << "DDS entities cleaned up." << std::endl;
        }
        _isInitialized = false;
    }

    // Disable copy constructor and assignment operator
    DDSCommunicator(const DDSCommunicator&) = delete;
    DDSCommunicator& operator=(const DDSCommunicator&) = delete;
};

#endif // DDS_COMMUNICATOR_HPP
